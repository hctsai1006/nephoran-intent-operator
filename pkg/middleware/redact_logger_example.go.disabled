// Package middleware provides HTTP middleware components for the Nephoran Intent Operator
package middleware

import (
	"encoding/json"
	"log/slog"
	"net/http"
	"os"
	"time"
)

// ExampleRedactLoggerSetup demonstrates how to set up the redact logger middleware
func ExampleRedactLoggerSetup() {
	// Create a structured logger
	logger := slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
		Level: slog.LevelDebug,
	}))

	// Create configuration with custom settings
	config := &RedactLoggerConfig{
		Enabled:      true,
		LogLevel:     slog.LevelInfo,
		
		// Skip logging for health check endpoints
		SkipPaths: []string{
			"/health",
			"/healthz",
			"/ready",
			"/readyz",
			"/metrics",
			"/debug/pprof/*",
		},
		
		// Different log levels for specific paths
		PathLogLevels: map[string]slog.Level{
			"/debug":     slog.LevelDebug,
			"/api/admin": slog.LevelDebug,
		},
		
		// Headers to redact - add custom ones
		SensitiveHeaders: []string{
			"Authorization",
			"Cookie",
			"Set-Cookie",
			"X-API-Key",
			"X-Auth-Token",
			"X-Session-Token",
			"X-CSRF-Token",
			"X-Custom-Secret",  // Custom header
		},
		
		// Query parameters to redact
		SensitiveQueryParams: []string{
			"token",
			"api_key",
			"apikey",
			"secret",
			"password",
			"auth",
			"session_id",  // Custom parameter
		},
		
		// JSON fields to redact in request/response bodies
		SensitiveJSONFields: []string{
			"password",
			"secret",
			"token",
			"api_key",
			"apiKey",
			"private_key",
			"privateKey",
			"ssn",          // Custom field
			"credit_card",  // Custom field
		},
		
		// Body logging configuration
		LogRequestBody:  true,
		LogResponseBody: false,  // Usually not needed, can be verbose
		MaxBodySize:     8192,   // 8KB limit
		
		// Performance monitoring
		SlowRequestThreshold: 3 * time.Second,
		
		// Privacy settings
		IncludeClientIP:  true,
		IncludeUserAgent: true,
		
		// Correlation ID settings
		CorrelationIDHeader:   "X-Request-ID",
		GenerateCorrelationID: true,
		
		RedactedValue: "[REDACTED]",
	}

	// Create the middleware
	redactLogger, err := NewRedactLogger(config, logger)
	if err != nil {
		panic(err)
	}

	// Create a simple handler
	handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Get correlation ID from context
		correlationID := r.Context().Value("correlation_id")
		
		// Use correlation ID in business logic
		logger.Info("Processing request",
			slog.String("correlation_id", correlationID.(string)),
			slog.String("endpoint", r.URL.Path))
		
		// Simulate some processing
		time.Sleep(100 * time.Millisecond)
		
		// Send response
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		json.NewEncoder(w).Encode(map[string]interface{}{
			"status":  "success",
			"message": "Request processed",
		})
	})

	// Apply middleware chain
	mux := http.NewServeMux()
	
	// Apply middleware in correct order
	// 1. Security headers first
	securityHeaders := NewSecurityHeaders(nil, logger)
	
	// 2. Then logging/correlation
	// 3. Then rate limiting, auth, etc.
	
	finalHandler := securityHeaders.Middleware(
		redactLogger.Middleware(
			handler,
		),
	)
	
	mux.Handle("/", finalHandler)

	// Start server
	server := &http.Server{
		Addr:    ":8080",
		Handler: mux,
	}
	
	_ = server
	// server.ListenAndServe()
}

// ExampleCustomRedaction demonstrates custom redaction patterns
func ExampleCustomRedaction() {
	logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))

	// Create config with custom patterns
	config := &RedactLoggerConfig{
		Enabled:  true,
		LogLevel: slog.LevelInfo,
		
		// Add custom sensitive patterns
		SensitiveHeaders: append(
			DefaultRedactLoggerConfig().SensitiveHeaders,
			"X-Company-Secret",
			"X-Internal-Token",
		),
		
		SensitiveQueryParams: append(
			DefaultRedactLoggerConfig().SensitiveQueryParams,
			"customer_id",
			"account_number",
		),
		
		SensitiveJSONFields: append(
			DefaultRedactLoggerConfig().SensitiveJSONFields,
			"social_security_number",
			"bank_account",
			"routing_number",
		),
		
		LogRequestBody: true,
		MaxBodySize:    2048,
	}

	redactLogger, _ := NewRedactLogger(config, logger)
	
	// Use with your handlers
	_ = redactLogger
}

// ExampleDynamicConfiguration demonstrates runtime configuration updates
func ExampleDynamicConfiguration() {
	logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
	
	// Start with default config
	config := DefaultRedactLoggerConfig()
	redactLogger, _ := NewRedactLogger(config, logger)

	// Later, update configuration based on requirements
	newConfig := DefaultRedactLoggerConfig()
	
	// Enable request body logging for debugging
	newConfig.LogRequestBody = true
	newConfig.LogResponseBody = true
	
	// Add temporary debug paths
	newConfig.PathLogLevels["/api/debug"] = slog.LevelDebug
	
	// Update the logger
	err := redactLogger.UpdateConfig(newConfig)
	if err != nil {
		logger.Error("Failed to update logger config", slog.String("error", err.Error()))
	}
	
	// Get current stats
	stats := redactLogger.GetStats()
	logger.Info("Logger stats", slog.Any("stats", stats))
}

// ExampleIntegrationWithTracing shows integration with distributed tracing
func ExampleIntegrationWithTracing() {
	logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
	
	config := &RedactLoggerConfig{
		Enabled:               true,
		LogLevel:              slog.LevelInfo,
		CorrelationIDHeader:   "X-Trace-ID",  // Use trace ID as correlation
		GenerateCorrelationID: false,         // Let tracing system generate
		IncludeClientIP:       true,
		LogRequestBody:        true,
		MaxBodySize:           4096,
	}

	redactLogger, _ := NewRedactLogger(config, logger)

	handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Extract trace ID from context (set by tracing middleware)
		traceID := r.Header.Get("X-Trace-ID")
		
		// Log with trace context
		logger.Info("Request processing",
			slog.String("trace_id", traceID),
			slog.String("method", r.Method),
			slog.String("path", r.URL.Path))
		
		w.WriteHeader(http.StatusOK)
	})

	// Apply middleware chain with tracing
	// tracingMiddleware -> redactLogger -> handler
	_ = redactLogger.Middleware(handler)
}

// ExampleSecurityAuditMode demonstrates high-security audit logging
func ExampleSecurityAuditMode() {
	// Use a dedicated audit logger
	auditFile, _ := os.OpenFile("/var/log/audit.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	auditLogger := slog.New(slog.NewJSONHandler(auditFile, &slog.HandlerOptions{
		Level: slog.LevelDebug,  // Log everything for audit
	}))

	config := &RedactLoggerConfig{
		Enabled:  true,
		LogLevel: slog.LevelDebug,  // Capture all events
		
		// Never skip any paths in audit mode
		SkipPaths: []string{},
		
		// Log everything
		LogRequestBody:  true,
		LogResponseBody: true,
		MaxBodySize:     65536,  // 64KB for complete capture
		
		// Include all metadata
		IncludeClientIP:       true,
		IncludeUserAgent:      true,
		GenerateCorrelationID: true,
		
		// Extensive redaction for compliance
		SensitiveHeaders: []string{
			"Authorization", "Cookie", "Set-Cookie",
			"X-API-Key", "X-Auth-Token", "X-Session-Token",
			"Proxy-Authorization", "X-Amz-Security-Token",
		},
		
		SensitiveJSONFields: []string{
			"password", "secret", "token", "key",
			"ssn", "sin", "nino",  // Social security numbers
			"pan", "credit_card", "cvv",  // Payment info
			"pin", "passcode",  // PINs
		},
		
		SlowRequestThreshold: 1 * time.Second,  // Strict performance monitoring
	}

	redactLogger, _ := NewRedactLogger(config, auditLogger)
	
	// Use for all sensitive endpoints
	_ = redactLogger
}

// ExamplePerformanceOptimized demonstrates performance-optimized configuration
func ExamplePerformanceOptimized() {
	// Use a fast handler with minimal allocations
	logger := slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{
		Level: slog.LevelWarn,  // Only warnings and errors
	}))

	config := &RedactLoggerConfig{
		Enabled:  true,
		LogLevel: slog.LevelWarn,  // Minimal logging
		
		// Skip non-critical paths
		SkipPaths: []string{
			"/health*",
			"/metrics",
			"/favicon.ico",
			"/static/*",
			"/assets/*",
		},
		
		// Disable body logging for performance
		LogRequestBody:  false,
		LogResponseBody: false,
		
		// Only essential headers
		SensitiveHeaders: []string{
			"Authorization",
			"X-API-Key",
		},
		
		// Minimal metadata
		IncludeClientIP:       false,
		IncludeUserAgent:      false,
		GenerateCorrelationID: false,  // Use existing only
		
		// Higher threshold for slow requests
		SlowRequestThreshold: 10 * time.Second,
	}

	redactLogger, _ := NewRedactLogger(config, logger)
	
	// Use for high-traffic endpoints
	_ = redactLogger
}