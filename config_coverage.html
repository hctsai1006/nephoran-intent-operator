
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/thc1006/nephoran-intent-operator/pkg/config/config.go (27.7%)</option>
				
				<option value="file1">github.com/thc1006/nephoran-intent-operator/pkg/config/file_secrets.go (0.0%)</option>
				
				<option value="file2">github.com/thc1006/nephoran-intent-operator/pkg/config/llm_processor.go (0.0%)</option>
				
				<option value="file3">github.com/thc1006/nephoran-intent-operator/pkg/config/secrets.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"
)

// Config holds all configuration for the Nephoran Intent Operator
type Config struct {
        // Controller configuration
        MetricsAddr          string
        ProbeAddr            string
        EnableLeaderElection bool

        // LLM Processor configuration
        LLMProcessorURL     string
        LLMProcessorTimeout time.Duration

        // RAG API configuration
        RAGAPIURLInternal string
        RAGAPIURLExternal string
        RAGAPITimeout     time.Duration

        // Git integration configuration
        GitRepoURL string
        GitToken   string
        GitBranch  string

        // Weaviate configuration
        WeaviateURL   string
        WeaviateIndex string

        // OpenAI configuration
        OpenAIAPIKey         string
        OpenAIModel          string
        OpenAIEmbeddingModel string

        // Kubernetes configuration
        Namespace string
        CRDPath   string
}

// DefaultConfig returns a configuration with sensible defaults
func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                MetricsAddr:          ":8080",
                ProbeAddr:            ":8081",
                EnableLeaderElection: false,

                LLMProcessorURL:     "http://llm-processor.default.svc.cluster.local:8080",
                LLMProcessorTimeout: 30 * time.Second,

                RAGAPIURLInternal: "http://rag-api.default.svc.cluster.local:5001",
                RAGAPIURLExternal: "http://localhost:5001",
                RAGAPITimeout:     30 * time.Second,

                GitBranch: "main",

                WeaviateURL:   "http://weaviate.default.svc.cluster.local:8080",
                WeaviateIndex: "telecom_knowledge",

                OpenAIModel:          "gpt-4o-mini",
                OpenAIEmbeddingModel: "text-embedding-3-large",

                Namespace: "default",
                CRDPath:   "deployments/crds",
        }
}</span>

// LoadFromEnv loads configuration from environment variables
func LoadFromEnv() (*Config, error) <span class="cov0" title="0">{
        cfg := DefaultConfig()

        // Override defaults with environment variables if they exist
        if val := os.Getenv("METRICS_ADDR"); val != "" </span><span class="cov0" title="0">{
                cfg.MetricsAddr = val
        }</span>

        <span class="cov0" title="0">if val := os.Getenv("PROBE_ADDR"); val != "" </span><span class="cov0" title="0">{
                cfg.ProbeAddr = val
        }</span>

        <span class="cov0" title="0">if val := os.Getenv("ENABLE_LEADER_ELECTION"); val != "" </span><span class="cov0" title="0">{
                if b, err := strconv.ParseBool(val); err == nil </span><span class="cov0" title="0">{
                        cfg.EnableLeaderElection = b
                }</span>
        }

        <span class="cov0" title="0">if val := os.Getenv("LLM_PROCESSOR_URL"); val != "" </span><span class="cov0" title="0">{
                cfg.LLMProcessorURL = val
        }</span>

        <span class="cov0" title="0">if val := os.Getenv("LLM_PROCESSOR_TIMEOUT"); val != "" </span><span class="cov0" title="0">{
                if d, err := time.ParseDuration(val); err == nil </span><span class="cov0" title="0">{
                        cfg.LLMProcessorTimeout = d
                }</span>
        }

        <span class="cov0" title="0">if val := os.Getenv("RAG_API_URL"); val != "" </span><span class="cov0" title="0">{
                cfg.RAGAPIURLInternal = val
        }</span>

        <span class="cov0" title="0">if val := os.Getenv("RAG_API_URL_EXTERNAL"); val != "" </span><span class="cov0" title="0">{
                cfg.RAGAPIURLExternal = val
        }</span>

        <span class="cov0" title="0">if val := os.Getenv("RAG_API_TIMEOUT"); val != "" </span><span class="cov0" title="0">{
                if d, err := time.ParseDuration(val); err == nil </span><span class="cov0" title="0">{
                        cfg.RAGAPITimeout = d
                }</span>
        }

        <span class="cov0" title="0">if val := os.Getenv("GIT_REPO_URL"); val != "" </span><span class="cov0" title="0">{
                cfg.GitRepoURL = val
        }</span>

        <span class="cov0" title="0">if val := os.Getenv("GIT_TOKEN"); val != "" </span><span class="cov0" title="0">{
                cfg.GitToken = val
        }</span>

        <span class="cov0" title="0">if val := os.Getenv("GIT_BRANCH"); val != "" </span><span class="cov0" title="0">{
                cfg.GitBranch = val
        }</span>

        <span class="cov0" title="0">if val := os.Getenv("WEAVIATE_URL"); val != "" </span><span class="cov0" title="0">{
                cfg.WeaviateURL = val
        }</span>

        <span class="cov0" title="0">if val := os.Getenv("WEAVIATE_INDEX"); val != "" </span><span class="cov0" title="0">{
                cfg.WeaviateIndex = val
        }</span>

        <span class="cov0" title="0">if val := os.Getenv("OPENAI_API_KEY"); val != "" </span><span class="cov0" title="0">{
                cfg.OpenAIAPIKey = val
        }</span>

        <span class="cov0" title="0">if val := os.Getenv("OPENAI_MODEL"); val != "" </span><span class="cov0" title="0">{
                cfg.OpenAIModel = val
        }</span>

        <span class="cov0" title="0">if val := os.Getenv("OPENAI_EMBEDDING_MODEL"); val != "" </span><span class="cov0" title="0">{
                cfg.OpenAIEmbeddingModel = val
        }</span>

        <span class="cov0" title="0">if val := os.Getenv("NAMESPACE"); val != "" </span><span class="cov0" title="0">{
                cfg.Namespace = val
        }</span>

        <span class="cov0" title="0">if val := os.Getenv("CRD_PATH"); val != "" </span><span class="cov0" title="0">{
                cfg.CRDPath = val
        }</span>

        // Validate required configuration
        <span class="cov0" title="0">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("configuration validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return cfg, nil</span>
}

// Validate checks that required configuration is present
func (c *Config) Validate() error <span class="cov8" title="1">{
        var errors []string

        // Always required configuration
        if c.OpenAIAPIKey == "" </span><span class="cov8" title="1">{
                errors = append(errors, "OPENAI_API_KEY is required")
        }</span>

        // Git features validation - enabled when Git integration is intended
        // Git features are considered enabled when GitRepoURL is configured or
        // when other Git-related config suggests Git usage
        <span class="cov8" title="1">if c.isGitFeatureEnabled() </span><span class="cov8" title="1">{
                if c.GitRepoURL == "" </span><span class="cov8" title="1">{
                        errors = append(errors, "GIT_REPO_URL is required when Git features are enabled")
                }</span>
        }

        // LLM processing validation - enabled when LLM processing is intended
        // LLM processing is considered enabled when LLMProcessorURL is configured
        <span class="cov8" title="1">if c.isLLMProcessingEnabled() </span><span class="cov8" title="1">{
                if c.LLMProcessorURL == "" </span><span class="cov0" title="0">{
                        errors = append(errors, "LLM_PROCESSOR_URL is required when LLM processing is enabled")
                }</span>
        }

        // RAG features validation - enabled when RAG features are intended
        // RAG features are considered enabled when RAG API URL is configured or
        // when RAG-related infrastructure is configured
        <span class="cov8" title="1">if c.isRAGFeatureEnabled() </span><span class="cov8" title="1">{
                if c.RAGAPIURLInternal == "" </span><span class="cov8" title="1">{
                        errors = append(errors, "RAG_API_URL_INTERNAL is required when RAG features are enabled")
                }</span>
        }

        // Return validation errors if any
        <span class="cov8" title="1">if len(errors) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("configuration validation failed: %s", strings.Join(errors, "; "))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// isGitFeatureEnabled checks if Git features are enabled based on configuration
func (c *Config) isGitFeatureEnabled() bool <span class="cov8" title="1">{
        // Git features are enabled when GitRepoURL is set or when Git token is provided
        // (indicating intention to use Git even if URL is missing - validation error)
        return c.GitRepoURL != "" || c.GitToken != ""
}</span>

// isLLMProcessingEnabled checks if LLM processing is enabled based on configuration
func (c *Config) isLLMProcessingEnabled() bool <span class="cov8" title="1">{
        // LLM processing is enabled when LLMProcessorURL is set
        // This follows the pattern seen in networkintent_constructor.go
        return c.LLMProcessorURL != ""
}</span>

// isRAGFeatureEnabled checks if RAG features are enabled based on configuration
func (c *Config) isRAGFeatureEnabled() bool <span class="cov8" title="1">{
        // RAG features are enabled when RAG API URL is set or when Weaviate is configured
        // (indicating intention to use RAG even if internal URL is missing - validation error)
        return c.RAGAPIURLInternal != "" || c.RAGAPIURLExternal != "" || c.WeaviateURL != ""
}</span>

// GetRAGAPIURL returns the appropriate RAG API URL based on environment
func (c *Config) GetRAGAPIURL(useInternal bool) string <span class="cov0" title="0">{
        if useInternal </span><span class="cov0" title="0">{
                return c.RAGAPIURLInternal
        }</span>
        <span class="cov0" title="0">return c.RAGAPIURLExternal</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "crypto/subtle"
        "fmt"
        "io/ioutil"
        "os"
        "path/filepath"
        "strings"
)

// SecretLoader provides secure methods for loading secrets from files
type SecretLoader struct {
        basePath string
}

// NewSecretLoader creates a new SecretLoader with validation
func NewSecretLoader(basePath string) (*SecretLoader, error) <span class="cov0" title="0">{
        // Validate base path to prevent directory traversal
        if !strings.HasPrefix(basePath, "/secrets/") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid base path: must be under /secrets/")
        }</span>
        
        <span class="cov0" title="0">absPath, err := filepath.Abs(basePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to resolve absolute path: %w", err)
        }</span>
        
        <span class="cov0" title="0">return &amp;SecretLoader{basePath: absPath}, nil</span>
}

// LoadSecret reads a secret from a file with security checks
func (sl *SecretLoader) LoadSecret(filename string) (string, error) <span class="cov0" title="0">{
        // Validate filename to prevent directory traversal
        if strings.Contains(filename, "..") || strings.Contains(filename, "/") </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid filename: %s", filename)
        }</span>
        
        <span class="cov0" title="0">fullPath := filepath.Join(sl.basePath, filename)
        
        // Verify the resolved path is still under the base path
        if !strings.HasPrefix(fullPath, sl.basePath) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("path traversal detected")
        }</span>
        
        // Check file permissions
        <span class="cov0" title="0">info, err := os.Stat(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to stat file: %w", err)
        }</span>
        
        // Warn if file permissions are too open
        <span class="cov0" title="0">mode := info.Mode()
        if mode&amp;0077 != 0 </span><span class="cov0" title="0">{
                // Log warning but continue - file has group/other permissions
                fmt.Fprintf(os.Stderr, "WARNING: Secret file %s has overly permissive permissions: %v\n", fullPath, mode)
        }</span>
        
        // Read the secret
        <span class="cov0" title="0">data, err := ioutil.ReadFile(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read secret: %w", err)
        }</span>
        
        // Remove any trailing whitespace
        <span class="cov0" title="0">secret := strings.TrimSpace(string(data))
        
        // Clear the byte array from memory (best effort)
        for i := range data </span><span class="cov0" title="0">{
                data[i] = 0
        }</span>
        
        <span class="cov0" title="0">return secret, nil</span>
}

// LoadSecretWithFallback attempts to load from file, falls back to env var
func (sl *SecretLoader) LoadSecretWithFallback(filename, envVar string) (string, error) <span class="cov0" title="0">{
        // Try file first
        secret, err := sl.LoadSecret(filename)
        if err == nil &amp;&amp; secret != "" </span><span class="cov0" title="0">{
                return secret, nil
        }</span>
        
        // Fall back to environment variable
        <span class="cov0" title="0">envValue := os.Getenv(envVar)
        if envValue != "" </span><span class="cov0" title="0">{
                return envValue, nil
        }</span>
        
        <span class="cov0" title="0">return "", fmt.Errorf("secret not found in file %s or env var %s", filename, envVar)</span>
}

// SecureCompare performs a constant-time comparison of two secrets
func SecureCompare(a, b string) bool <span class="cov0" title="0">{
        return subtle.ConstantTimeCompare([]byte(a), []byte(b)) == 1
}</span>

// ClearString attempts to clear a string from memory (best effort)
func ClearString(s *string) <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        // Convert to byte slice and clear
        <span class="cov0" title="0">b := []byte(*s)
        for i := range b </span><span class="cov0" title="0">{
                b[i] = 0
        }</span>
        
        // Set to empty string
        <span class="cov0" title="0">*s = ""</span>
}

// LoadLLMAPIKeyFromFile loads LLM API keys from file-based secrets
func LoadLLMAPIKeyFromFile(provider string) (string, error) <span class="cov0" title="0">{
        loader, err := NewSecretLoader("/secrets/llm")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        
        <span class="cov0" title="0">filename := fmt.Sprintf("%s-api-key", strings.ToLower(provider))
        return loader.LoadSecretWithFallback(filename, fmt.Sprintf("%s_API_KEY", strings.ToUpper(provider)))</span>
}

// LoadAPIKeyFromFile loads the general API key from file
func LoadAPIKeyFromFile() (string, error) <span class="cov0" title="0">{
        loader, err := NewSecretLoader("/secrets/api-keys")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        
        <span class="cov0" title="0">return loader.LoadSecretWithFallback("api-key", "API_KEY")</span>
}

// LoadJWTSecretKeyFromFile loads the JWT secret key from file
func LoadJWTSecretKeyFromFile() (string, error) <span class="cov0" title="0">{
        loader, err := NewSecretLoader("/secrets/jwt")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        
        <span class="cov0" title="0">return loader.LoadSecretWithFallback("jwt-secret-key", "JWT_SECRET_KEY")</span>
}

// LoadOAuth2ClientSecretFromFile loads OAuth2 client secrets from file
func LoadOAuth2ClientSecretFromFile() (string, error) <span class="cov0" title="0">{
        loader, err := NewSecretLoader("/secrets/oauth2")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        
        <span class="cov0" title="0">return loader.LoadSecretWithFallback("client-secret", "OAUTH2_CLIENT_SECRET")</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"
)

// LLMProcessorConfig holds configuration specific to the LLM processor service
type LLMProcessorConfig struct {
        // Service Configuration
        Port             string
        LogLevel         string
        ServiceVersion   string
        GracefulShutdown time.Duration

        // LLM Configuration
        LLMBackendType string
        LLMAPIKey      string
        LLMModelName   string
        LLMTimeout     time.Duration
        LLMMaxTokens   int

        // RAG Configuration
        RAGAPIURL  string
        RAGTimeout time.Duration
        RAGEnabled bool

        // Streaming Configuration
        StreamingEnabled     bool
        MaxConcurrentStreams int
        StreamTimeout        time.Duration

        // Context Management
        EnableContextBuilder bool
        MaxContextTokens     int
        ContextTTL           time.Duration

        // Security Configuration
        APIKeyRequired bool
        APIKey         string
        CORSEnabled    bool
        AllowedOrigins string

        // Performance Configuration
        RequestTimeout time.Duration
        MaxRequestSize int64

        // Circuit Breaker Configuration
        CircuitBreakerEnabled   bool
        CircuitBreakerThreshold int
        CircuitBreakerTimeout   time.Duration

        // Rate Limiting
        RateLimitEnabled        bool
        RateLimitRequestsPerMin int
        RateLimitBurst          int

        // Retry Configuration
        MaxRetries   int
        RetryDelay   time.Duration
        RetryBackoff string

        // OAuth2 Authentication Configuration
        AuthEnabled    bool
        AuthConfigFile string
        JWTSecretKey   string
        RequireAuth    bool
        AdminUsers     []string
        OperatorUsers  []string

        // Secret Management Configuration
        UseKubernetesSecrets bool
        SecretNamespace      string
}

// DefaultLLMProcessorConfig returns a configuration with sensible defaults
func DefaultLLMProcessorConfig() *LLMProcessorConfig <span class="cov0" title="0">{
        return &amp;LLMProcessorConfig{
                Port:             "8080",
                LogLevel:         "info",
                ServiceVersion:   "v2.0.0",
                GracefulShutdown: 30 * time.Second,

                LLMBackendType: "rag",
                LLMModelName:   "gpt-4o-mini",
                LLMTimeout:     60 * time.Second,
                LLMMaxTokens:   2048,

                RAGAPIURL:  "http://rag-api:5001",
                RAGTimeout: 30 * time.Second,
                RAGEnabled: true,

                StreamingEnabled:     true,
                MaxConcurrentStreams: 100,
                StreamTimeout:        5 * time.Minute,

                EnableContextBuilder: true,
                MaxContextTokens:     6000,
                ContextTTL:           5 * time.Minute,

                APIKeyRequired: false,
                CORSEnabled:    true,
                AllowedOrigins: "*",

                RequestTimeout: 30 * time.Second,
                MaxRequestSize: 1048576, // 1MB

                CircuitBreakerEnabled:   true,
                CircuitBreakerThreshold: 5,
                CircuitBreakerTimeout:   60 * time.Second,

                RateLimitEnabled:        true,
                RateLimitRequestsPerMin: 60,
                RateLimitBurst:          10,

                MaxRetries:   3,
                RetryDelay:   1 * time.Second,
                RetryBackoff: "exponential",

                AuthEnabled:   true,
                RequireAuth:   true,
                AdminUsers:    []string{},
                OperatorUsers: []string{},

                UseKubernetesSecrets: true,
                SecretNamespace:      "nephoran-system",
        }
}</span>

// LoadLLMProcessorConfig loads configuration from environment variables with validation
func LoadLLMProcessorConfig() (*LLMProcessorConfig, error) <span class="cov0" title="0">{
        cfg := DefaultLLMProcessorConfig()

        // Load configuration with validation
        var validationErrors []string

        // Service Configuration
        cfg.Port = getEnvWithValidation("PORT", cfg.Port, validatePort, &amp;validationErrors)
        cfg.LogLevel = getEnvWithValidation("LOG_LEVEL", cfg.LogLevel, validateLogLevel, &amp;validationErrors)
        cfg.ServiceVersion = getEnvOrDefault("SERVICE_VERSION", cfg.ServiceVersion)
        cfg.GracefulShutdown = parseDurationWithValidation("GRACEFUL_SHUTDOWN_TIMEOUT", cfg.GracefulShutdown, &amp;validationErrors)

        // LLM Configuration
        cfg.LLMBackendType = getEnvWithValidation("LLM_BACKEND_TYPE", cfg.LLMBackendType, validateLLMBackendType, &amp;validationErrors)
        // Load LLM API key from file or env based on backend type
        llmAPIKey, err := LoadLLMAPIKeyFromFile(cfg.LLMBackendType)
        if err != nil &amp;&amp; cfg.LLMBackendType != "mock" &amp;&amp; cfg.LLMBackendType != "rag" </span><span class="cov0" title="0">{
                validationErrors = append(validationErrors, fmt.Sprintf("LLM API Key: %v", err))
        }</span>
        <span class="cov0" title="0">cfg.LLMAPIKey = llmAPIKey
        cfg.LLMModelName = getEnvOrDefault("LLM_MODEL_NAME", cfg.LLMModelName)
        cfg.LLMTimeout = parseDurationWithValidation("LLM_TIMEOUT", cfg.LLMTimeout, &amp;validationErrors)
        cfg.LLMMaxTokens = parseIntWithValidation("LLM_MAX_TOKENS", cfg.LLMMaxTokens, validatePositiveInt, &amp;validationErrors)

        // RAG Configuration
        cfg.RAGAPIURL = getEnvWithValidation("RAG_API_URL", cfg.RAGAPIURL, validateURL, &amp;validationErrors)
        cfg.RAGTimeout = parseDurationWithValidation("RAG_TIMEOUT", cfg.RAGTimeout, &amp;validationErrors)
        cfg.RAGEnabled = parseBoolWithDefault("RAG_ENABLED", cfg.RAGEnabled)

        // Streaming Configuration
        cfg.StreamingEnabled = parseBoolWithDefault("STREAMING_ENABLED", cfg.StreamingEnabled)
        cfg.MaxConcurrentStreams = parseIntWithValidation("MAX_CONCURRENT_STREAMS", cfg.MaxConcurrentStreams, validatePositiveInt, &amp;validationErrors)
        cfg.StreamTimeout = parseDurationWithValidation("STREAM_TIMEOUT", cfg.StreamTimeout, &amp;validationErrors)

        // Context Management
        cfg.EnableContextBuilder = parseBoolWithDefault("ENABLE_CONTEXT_BUILDER", cfg.EnableContextBuilder)
        cfg.MaxContextTokens = parseIntWithValidation("MAX_CONTEXT_TOKENS", cfg.MaxContextTokens, validatePositiveInt, &amp;validationErrors)
        cfg.ContextTTL = parseDurationWithValidation("CONTEXT_TTL", cfg.ContextTTL, &amp;validationErrors)

        // Security Configuration
        cfg.APIKeyRequired = parseBoolWithDefault("API_KEY_REQUIRED", cfg.APIKeyRequired)
        // Load API key from file or env
        apiKey, err := LoadAPIKeyFromFile()
        if err != nil &amp;&amp; cfg.APIKeyRequired </span><span class="cov0" title="0">{
                validationErrors = append(validationErrors, fmt.Sprintf("API Key: %v", err))
        }</span>
        <span class="cov0" title="0">cfg.APIKey = apiKey
        cfg.CORSEnabled = parseBoolWithDefault("CORS_ENABLED", cfg.CORSEnabled)
        cfg.AllowedOrigins = getEnvOrDefault("ALLOWED_ORIGINS", cfg.AllowedOrigins)

        // Performance Configuration
        cfg.RequestTimeout = parseDurationWithValidation("REQUEST_TIMEOUT", cfg.RequestTimeout, &amp;validationErrors)
        cfg.MaxRequestSize = parseInt64WithValidation("MAX_REQUEST_SIZE", cfg.MaxRequestSize, validatePositiveInt64, &amp;validationErrors)

        // Circuit Breaker Configuration
        cfg.CircuitBreakerEnabled = parseBoolWithDefault("CIRCUIT_BREAKER_ENABLED", cfg.CircuitBreakerEnabled)
        cfg.CircuitBreakerThreshold = parseIntWithValidation("CIRCUIT_BREAKER_THRESHOLD", cfg.CircuitBreakerThreshold, validatePositiveInt, &amp;validationErrors)
        cfg.CircuitBreakerTimeout = parseDurationWithValidation("CIRCUIT_BREAKER_TIMEOUT", cfg.CircuitBreakerTimeout, &amp;validationErrors)

        // Rate Limiting
        cfg.RateLimitEnabled = parseBoolWithDefault("RATE_LIMIT_ENABLED", cfg.RateLimitEnabled)
        cfg.RateLimitRequestsPerMin = parseIntWithValidation("RATE_LIMIT_REQUESTS_PER_MINUTE", cfg.RateLimitRequestsPerMin, validatePositiveInt, &amp;validationErrors)
        cfg.RateLimitBurst = parseIntWithValidation("RATE_LIMIT_BURST", cfg.RateLimitBurst, validatePositiveInt, &amp;validationErrors)

        // Retry Configuration
        cfg.MaxRetries = parseIntWithValidation("MAX_RETRIES", cfg.MaxRetries, validateNonNegativeInt, &amp;validationErrors)
        cfg.RetryDelay = parseDurationWithValidation("RETRY_DELAY", cfg.RetryDelay, &amp;validationErrors)
        cfg.RetryBackoff = getEnvWithValidation("RETRY_BACKOFF", cfg.RetryBackoff, validateRetryBackoff, &amp;validationErrors)

        // OAuth2 Authentication Configuration
        cfg.AuthEnabled = parseBoolWithDefault("AUTH_ENABLED", cfg.AuthEnabled)
        cfg.AuthConfigFile = os.Getenv("AUTH_CONFIG_FILE")
        // Load JWT secret key from file or env
        jwtSecretKey, err := LoadJWTSecretKeyFromFile()
        if err != nil &amp;&amp; cfg.AuthEnabled </span><span class="cov0" title="0">{
                validationErrors = append(validationErrors, fmt.Sprintf("JWT Secret Key: %v", err))
        }</span>
        <span class="cov0" title="0">cfg.JWTSecretKey = jwtSecretKey
        cfg.RequireAuth = parseBoolWithDefault("REQUIRE_AUTH", cfg.RequireAuth)
        cfg.AdminUsers = parseStringSlice(getEnvOrDefault("ADMIN_USERS", ""))
        cfg.OperatorUsers = parseStringSlice(getEnvOrDefault("OPERATOR_USERS", ""))

        // Secret Management Configuration
        cfg.UseKubernetesSecrets = parseBoolWithDefault("USE_KUBERNETES_SECRETS", cfg.UseKubernetesSecrets)
        cfg.SecretNamespace = getEnvOrDefault("SECRET_NAMESPACE", cfg.SecretNamespace)

        // Return validation errors if any
        if len(validationErrors) &gt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("configuration validation failed: %s", strings.Join(validationErrors, "; "))
        }</span>

        // Perform additional cross-field validation
        <span class="cov0" title="0">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("configuration validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return cfg, nil</span>
}

// Validate performs comprehensive validation of the configuration
func (c *LLMProcessorConfig) Validate() error <span class="cov0" title="0">{
        var errors []string

        // Validate required fields based on configuration
        if c.LLMAPIKey == "" &amp;&amp; c.LLMBackendType != "mock" &amp;&amp; c.LLMBackendType != "rag" </span><span class="cov0" title="0">{
                errors = append(errors, "OPENAI_API_KEY is required for non-mock/non-rag backends")
        }</span>

        <span class="cov0" title="0">if c.AuthEnabled &amp;&amp; c.JWTSecretKey == "" </span><span class="cov0" title="0">{
                errors = append(errors, "JWT_SECRET_KEY is required when authentication is enabled")
        }</span>

        <span class="cov0" title="0">if c.APIKeyRequired &amp;&amp; c.APIKey == "" </span><span class="cov0" title="0">{
                errors = append(errors, "API_KEY is required when API key authentication is enabled")
        }</span>

        // Validate logical constraints
        <span class="cov0" title="0">if c.MaxConcurrentStreams &gt; 1000 </span><span class="cov0" title="0">{
                errors = append(errors, "MAX_CONCURRENT_STREAMS should not exceed 1000 for performance reasons")
        }</span>

        <span class="cov0" title="0">if c.MaxContextTokens &gt; 32000 </span><span class="cov0" title="0">{
                errors = append(errors, "MAX_CONTEXT_TOKENS should not exceed 32000 for most models")
        }</span>

        <span class="cov0" title="0">if c.CircuitBreakerThreshold &gt; 50 </span><span class="cov0" title="0">{
                errors = append(errors, "CIRCUIT_BREAKER_THRESHOLD should be reasonable (≤50)")
        }</span>

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("%s", strings.Join(errors, "; "))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Helper functions for validation and parsing

func getEnvOrDefault(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvWithValidation(key, defaultValue string, validator func(string) error, errors *[]string) string <span class="cov0" title="0">{
        value := getEnvOrDefault(key, defaultValue)
        if err := validator(value); err != nil </span><span class="cov0" title="0">{
                *errors = append(*errors, fmt.Sprintf("%s: %v", key, err))
        }</span>
        <span class="cov0" title="0">return value</span>
}

func parseDurationWithValidation(key string, defaultValue time.Duration, errors *[]string) time.Duration <span class="cov0" title="0">{
        if valueStr := os.Getenv(key); valueStr != "" </span><span class="cov0" title="0">{
                if d, err := time.ParseDuration(valueStr); err == nil </span><span class="cov0" title="0">{
                        if d &lt;= 0 </span><span class="cov0" title="0">{
                                *errors = append(*errors, fmt.Sprintf("%s: duration must be positive", key))
                                return defaultValue
                        }</span>
                        <span class="cov0" title="0">return d</span>
                } else<span class="cov0" title="0"> {
                        *errors = append(*errors, fmt.Sprintf("%s: invalid duration format: %v", key, err))
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func parseIntWithValidation(key string, defaultValue int, validator func(int) error, errors *[]string) int <span class="cov0" title="0">{
        if valueStr := os.Getenv(key); valueStr != "" </span><span class="cov0" title="0">{
                if value, err := strconv.Atoi(valueStr); err == nil </span><span class="cov0" title="0">{
                        if err := validator(value); err != nil </span><span class="cov0" title="0">{
                                *errors = append(*errors, fmt.Sprintf("%s: %v", key, err))
                                return defaultValue
                        }</span>
                        <span class="cov0" title="0">return value</span>
                } else<span class="cov0" title="0"> {
                        *errors = append(*errors, fmt.Sprintf("%s: invalid integer format: %v", key, err))
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func parseInt64WithValidation(key string, defaultValue int64, validator func(int64) error, errors *[]string) int64 <span class="cov0" title="0">{
        if valueStr := os.Getenv(key); valueStr != "" </span><span class="cov0" title="0">{
                if value, err := strconv.ParseInt(valueStr, 10, 64); err == nil </span><span class="cov0" title="0">{
                        if err := validator(value); err != nil </span><span class="cov0" title="0">{
                                *errors = append(*errors, fmt.Sprintf("%s: %v", key, err))
                                return defaultValue
                        }</span>
                        <span class="cov0" title="0">return value</span>
                } else<span class="cov0" title="0"> {
                        *errors = append(*errors, fmt.Sprintf("%s: invalid integer format: %v", key, err))
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func parseBoolWithDefault(key string, defaultValue bool) bool <span class="cov0" title="0">{
        if valueStr := os.Getenv(key); valueStr != "" </span><span class="cov0" title="0">{
                return valueStr == "true" || valueStr == "1"
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func parseStringSlice(s string) []string <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        <span class="cov0" title="0">result := []string{}
        for _, item := range strings.Split(s, ",") </span><span class="cov0" title="0">{
                if trimmed := strings.TrimSpace(item); trimmed != "" </span><span class="cov0" title="0">{
                        result = append(result, trimmed)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// Validation functions

func validatePort(port string) error <span class="cov0" title="0">{
        if portNum, err := strconv.Atoi(port); err != nil || portNum &lt; 1 || portNum &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid port number, must be between 1 and 65535")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateLogLevel(level string) error <span class="cov0" title="0">{
        validLevels := []string{"debug", "info", "warn", "error"}
        for _, valid := range validLevels </span><span class="cov0" title="0">{
                if strings.ToLower(level) == valid </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("invalid log level, must be one of: %s", strings.Join(validLevels, ", "))</span>
}

func validateLLMBackendType(backendType string) error <span class="cov0" title="0">{
        validTypes := []string{"openai", "mistral", "rag", "mock"}
        for _, valid := range validTypes </span><span class="cov0" title="0">{
                if strings.ToLower(backendType) == valid </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("invalid LLM backend type, must be one of: %s", strings.Join(validTypes, ", "))</span>
}

func validateURL(url string) error <span class="cov0" title="0">{
        if url == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("URL cannot be empty")
        }</span>
        <span class="cov0" title="0">if !strings.HasPrefix(url, "http://") &amp;&amp; !strings.HasPrefix(url, "https://") </span><span class="cov0" title="0">{
                return fmt.Errorf("URL must start with http:// or https://")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validatePositiveInt(value int) error <span class="cov0" title="0">{
        if value &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("value must be positive")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateNonNegativeInt(value int) error <span class="cov0" title="0">{
        if value &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("value must be non-negative")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validatePositiveInt64(value int64) error <span class="cov0" title="0">{
        if value &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("value must be positive")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateRetryBackoff(backoff string) error <span class="cov0" title="0">{
        validBackoffs := []string{"fixed", "linear", "exponential"}
        for _, valid := range validBackoffs </span><span class="cov0" title="0">{
                if strings.ToLower(backoff) == valid </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("invalid retry backoff, must be one of: %s", strings.Join(validBackoffs, ", "))</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "context"
        "fmt"
        "os"
        "strings"

        "github.com/go-logr/logr"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        "sigs.k8s.io/controller-runtime/pkg/log"
)

// SecretManager manages Kubernetes secrets for API keys and sensitive data
type SecretManager struct {
        client    kubernetes.Interface
        namespace string
        logger    logr.Logger
}

// SecretConfig holds configuration for secret management
type SecretConfig struct {
        Namespace        string
        SecretName       string
        FallbackToEnvVar bool
}

// NewSecretManager creates a new SecretManager instance
func NewSecretManager(namespace string) (*SecretManager, error) <span class="cov0" title="0">{
        logger := log.Log.WithName("secret-manager")
        
        // Try to create in-cluster config first
        config, err := rest.InClusterConfig()
        if err != nil </span><span class="cov0" title="0">{
                logger.Info("Not running in cluster, secrets will fall back to environment variables")
                return &amp;SecretManager{
                        client:    nil,
                        namespace: namespace,
                        logger:    logger,
                }, nil
        }</span>

        <span class="cov0" title="0">clientset, err := kubernetes.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Kubernetes client: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;SecretManager{
                client:    clientset,
                namespace: namespace,
                logger:    logger,
        }, nil</span>
}

// GetSecretValue retrieves a value from a Kubernetes secret or falls back to environment variable
func (sm *SecretManager) GetSecretValue(ctx context.Context, secretName, key, envVarName string) (string, error) <span class="cov0" title="0">{
        // If no Kubernetes client available, fall back to environment variable
        if sm.client == nil </span><span class="cov0" title="0">{
                if value := os.Getenv(envVarName); value != "" </span><span class="cov0" title="0">{
                        sm.logger.Info("Using environment variable fallback", "env_var", envVarName)
                        return value, nil
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("no Kubernetes client available and environment variable %s not set", envVarName)</span>
        }

        // Try to get from Kubernetes secret first
        <span class="cov0" title="0">secret, err := sm.client.CoreV1().Secrets(sm.namespace).Get(ctx, secretName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                sm.logger.Info("Failed to get secret from Kubernetes, falling back to environment variable", 
                        "secret", secretName, "key", key, "error", err.Error())
                
                // Fall back to environment variable
                if value := os.Getenv(envVarName); value != "" </span><span class="cov0" title="0">{
                        return value, nil
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("secret %s/%s not found in Kubernetes and environment variable %s not set", 
                        secretName, key, envVarName)</span>
        }

        // Get the specific key from the secret
        <span class="cov0" title="0">if value, exists := secret.Data[key]; exists </span><span class="cov0" title="0">{
                sm.logger.Info("Retrieved value from Kubernetes secret", "secret", secretName, "key", key)
                return string(value), nil
        }</span>

        // Key not found in secret, fall back to environment variable
        <span class="cov0" title="0">sm.logger.Info("Key not found in secret, falling back to environment variable", 
                "secret", secretName, "key", key, "env_var", envVarName)
        
        if value := os.Getenv(envVarName); value != "" </span><span class="cov0" title="0">{
                return value, nil
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("key %s not found in secret %s and environment variable %s not set", 
                key, secretName, envVarName)</span>
}

// CreateSecretFromEnvVars creates a Kubernetes secret from environment variables
func (sm *SecretManager) CreateSecretFromEnvVars(ctx context.Context, secretName string, envVarMapping map[string]string) error <span class="cov0" title="0">{
        if sm.client == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no Kubernetes client available")
        }</span>

        <span class="cov0" title="0">secretData := make(map[string][]byte)
        
        // Collect values from environment variables
        for key, envVar := range envVarMapping </span><span class="cov0" title="0">{
                if value := os.Getenv(envVar); value != "" </span><span class="cov0" title="0">{
                        secretData[key] = []byte(value)
                }</span>
        }

        <span class="cov0" title="0">if len(secretData) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no environment variables found to create secret")
        }</span>

        <span class="cov0" title="0">secret := &amp;corev1.Secret{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      secretName,
                        Namespace: sm.namespace,
                        Labels: map[string]string{
                                "app.kubernetes.io/name":     "nephoran-intent-operator",
                                "app.kubernetes.io/component": "secrets",
                        },
                },
                Type: corev1.SecretTypeOpaque,
                Data: secretData,
        }

        _, err := sm.client.CoreV1().Secrets(sm.namespace).Create(ctx, secret, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create secret %s: %w", secretName, err)
        }</span>

        <span class="cov0" title="0">sm.logger.Info("Created Kubernetes secret", "secret", secretName, "keys", getKeys(secretData))
        return nil</span>
}

// UpdateSecret updates an existing Kubernetes secret
func (sm *SecretManager) UpdateSecret(ctx context.Context, secretName string, data map[string][]byte) error <span class="cov0" title="0">{
        if sm.client == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no Kubernetes client available")
        }</span>

        // Get existing secret
        <span class="cov0" title="0">secret, err := sm.client.CoreV1().Secrets(sm.namespace).Get(ctx, secretName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get secret %s: %w", secretName, err)
        }</span>

        // Update data
        <span class="cov0" title="0">secret.Data = data

        _, err = sm.client.CoreV1().Secrets(sm.namespace).Update(ctx, secret, metav1.UpdateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update secret %s: %w", secretName, err)
        }</span>

        <span class="cov0" title="0">sm.logger.Info("Updated Kubernetes secret", "secret", secretName, "keys", getKeys(data))
        return nil</span>
}

// SecretExists checks if a secret exists
func (sm *SecretManager) SecretExists(ctx context.Context, secretName string) bool <span class="cov0" title="0">{
        if sm.client == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">_, err := sm.client.CoreV1().Secrets(sm.namespace).Get(ctx, secretName, metav1.GetOptions{})
        return err == nil</span>
}

// GetAPIKeys retrieves common API keys used by the system
func (sm *SecretManager) GetAPIKeys(ctx context.Context) (*APIKeys, error) <span class="cov0" title="0">{
        keys := &amp;APIKeys{}
        var err error

        // Get OpenAI API key
        keys.OpenAI, err = sm.GetSecretValue(ctx, "llm-api-keys", "openai-api-key", "OPENAI_API_KEY")
        if err != nil </span><span class="cov0" title="0">{
                sm.logger.Info("OpenAI API key not available", "error", err.Error())
        }</span>

        // Get Weaviate API key
        <span class="cov0" title="0">keys.Weaviate, err = sm.GetSecretValue(ctx, "vector-db-keys", "weaviate-api-key", "WEAVIATE_API_KEY")
        if err != nil </span><span class="cov0" title="0">{
                sm.logger.Info("Weaviate API key not available", "error", err.Error())
        }</span>

        // Get Generic API key for authentication
        <span class="cov0" title="0">keys.Generic, err = sm.GetSecretValue(ctx, "auth-keys", "api-key", "API_KEY")
        if err != nil </span><span class="cov0" title="0">{
                sm.logger.Info("Generic API key not available", "error", err.Error())
        }</span>

        // Get JWT secret key
        <span class="cov0" title="0">keys.JWTSecret, err = sm.GetSecretValue(ctx, "auth-keys", "jwt-secret", "JWT_SECRET_KEY")
        if err != nil </span><span class="cov0" title="0">{
                sm.logger.Info("JWT secret key not available", "error", err.Error())
        }</span>

        <span class="cov0" title="0">return keys, nil</span>
}

// APIKeys holds all API keys used by the system
type APIKeys struct {
        OpenAI    string
        Weaviate  string
        Generic   string
        JWTSecret string
}

// IsEmpty returns true if all API keys are empty
func (ak *APIKeys) IsEmpty() bool <span class="cov0" title="0">{
        return ak.OpenAI == "" &amp;&amp; ak.Weaviate == "" &amp;&amp; ak.Generic == "" &amp;&amp; ak.JWTSecret == ""
}</span>

// getKeys returns the keys from a map for logging
func getKeys(data map[string][]byte) []string <span class="cov0" title="0">{
        keys := make([]string, 0, len(data))
        for k := range data </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// SanitizeForLog removes sensitive information for logging
func SanitizeForLog(value string) string <span class="cov0" title="0">{
        if len(value) &lt;= 8 </span><span class="cov0" title="0">{
                return strings.Repeat("*", len(value))
        }</span>
        <span class="cov0" title="0">return value[:4] + strings.Repeat("*", len(value)-8) + value[len(value)-4:]</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
